<ShaderProgram>
<Shader type="GL_VERTEX_SHADER">
#version 330

const vec2 g_vectices[4] =  vec2[](vec2(-1,-1), vec2(+1,-1), vec2(-1,+1), vec2(+1,+1));
const vec2 g_texCoords[4] = vec2[](vec2(0,0), vec2(1,0), vec2(0,1), vec2(1,1));

out vec2 vTexCoord;

void main()
{
	gl_Position = vec4( g_vectices[gl_VertexID], 0, 1);
	vTexCoord    = g_texCoords[gl_VertexID];
}
</Shader>
<Shader file_name="cook-torrance.shader" />
<Shader file_name="read-geom-data.shader" />
<Shader type="GL_FRAGMENT_SHADER">
#version 330
#extension GL_ARB_shading_language_420pack: enable
 
uniform mat4 uInverseProjectionMatrix;
uniform mat4 uInverseViewMatrix;

layout(binding=4) uniform samplerCube uEnvironmentMap;

in vec2 vTexCoord;

const float PI = 3.14159265359;

layout(location = 0) out vec3 oColor;

struct Material
{
  float roughness;
  vec3  diffuse_color;
  vec3  specular_color;
};
bool GetGeomData(vec2 texCoord, out vec4 position, out vec3 normal, out Material mat);
vec3 BRDF(vec3 n, vec3 l, vec3 v, Material mat);

void main()
{
	vec4 position;
	vec3 normal;
	Material mat;
	if(GetGeomData(vTexCoord, position, normal, mat))
	{
		vec3 v = normalize(-position.xyz);
		vec3 r = normalize(-reflect(v, normal));
		
		oColor = BRDF(normal, v, r, mat)*textureLod(uEnvironmentMap, 
			(uInverseViewMatrix*vec4(r,0)).xyz, 8*mat.roughness).rgb;
	}
	else
	{
		vec3 viewDir = (uInverseViewMatrix*vec4(normalize(position.xyz),0)).xyz;
		oColor = texture(uEnvironmentMap, viewDir).rgb;
	}
}
</Shader>
</ShaderProgram>
